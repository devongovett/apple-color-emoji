var fontkit = require('fontkit');
var fs = require('fs');
var rimraf = require('rimraf');
var mkdirp = require('mkdirp');
var punycode = require('punycode');
var regenerate = require('regenerate');

// delete the images directory and re-create it
rimraf.sync(__dirname + '/images');
mkdirp.sync(__dirname + '/images');

var font = fontkit.openSync('/System/Library/Fonts/Apple Color Emoji.ttf');
var set = regenerate();
var extraParts = [];

// Optionally specify characters in case identical glyphs can be produced with two distinct sets of characters
// e.g. ğŸ‡¨ğŸ‡µ and ğŸ‡«ğŸ‡·
function writeImage(glyph, unicode_characters) {
  // extract an image for this glyph
  var image = glyph.getImageForSize(64);
  
  if (image) {
    // compute the filename
    var name = (unicode_characters || punycode.ucs2.encode(glyph.codePoints.slice()))
      .split('')
      .map(function(c) { return ('0000' + c.charCodeAt(0).toString(16)).slice(-4) });
      
    // add codepoint to regex
    // if only one codepoint, we can add via regenerate (which compresses the regex)
    // otherwise, track the codepoints separately to be added later
    if (glyph.codePoints.length == 1) {
      set.add(glyph.codePoints[0]);
    } else  {
      extraParts.push('\\u' + name.join('\\ufe0f?\\u'));
    }
    
    fs.writeFileSync(__dirname + '/images/' + name.join('-') + '.png', image.data);
  }
}

var REGIONAL_INDICATORS = 'ğŸ‡¦ğŸ‡§ğŸ‡¨ğŸ‡©ğŸ‡ªğŸ‡«ğŸ‡¬ğŸ‡­ğŸ‡®ğŸ‡¯ğŸ‡°ğŸ‡±ğŸ‡²ğŸ‡³ğŸ‡´ğŸ‡µğŸ‡¶ğŸ‡·ğŸ‡¸ğŸ‡¹ğŸ‡ºğŸ‡»ğŸ‡¼ğŸ‡½ğŸ‡¾ğŸ‡¿'.match(/../g);
var MODIFIERS = ['âƒ ', 'âƒ£', 'ğŸ»', 'ğŸ¼', 'ğŸ½', 'ğŸ¾', 'ğŸ¿'];

// write longest characters first so regex works correctly
// first, the flag glyphs

REGIONAL_INDICATORS.forEach(function(first) {
  REGIONAL_INDICATORS.forEach(function(second) {
    var glyphs = font.layout(first + second).glyphs;
    if (glyphs.length === 1) {
      writeImage(glyphs[0], first + second)
    }
  });
});

font.characterSet.forEach(function(codePoint) {
  MODIFIERS.forEach(function(modifier) {
    var glyphs = font.layout(punycode.ucs2.encode([codePoint]) + modifier).glyphs;
    if (glyphs.length === 1) {
      writeImage(glyphs[0]);
    }
  });
  writeImage(font.glyphForCodePoint(codePoint));
});

// write the generated regex to a file to be included by the runtime module
fs.writeFileSync(__dirname + '/regex.js', 
  '/* AUTOGENERATED. DO NOT EDIT. */\n' +
  'module.exports = ' + new RegExp('(?:' + extraParts.sort().reverse().join('|') + '|' + set + ')[\\uFE00-\\uFE0D\\uFE0F]?(?!\\uFE0E)', 'g') + ';\n');
